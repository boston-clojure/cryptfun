<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="Mark's Presentaion">
		<meta name="author" content="Mark Champine">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">
		<!-- change default.css to sky.css to change theme-->


		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Clojure for Cryptanalysis</h1>
					<h3>Beginner's Edition</h3>
					<p>
						<small>Created by <a href="http://twitter.com/mchampine">@mchampine</a></small>
					</p>
				</section>

                                <section data-markdown>
                                  <script type="text/template">
                                    ## About Me

                                    - Mark Champine, Security Architect @ Akamai
                                        - email: tiez.mfitdrjw@izitir.mvt
                                            - Decode it first! Your first guess is probably right :)
                                    - Security professional, 15+ years. HP, IBM, Kronos, Akamai
                                    - Security Protocols (Kerberos, GSSAPI, SSL)
                                    - Security Standards (W3C Digital Signature, S/MIME, PKIX)
                                    - W3C DSig, Elliptic Curve Cryptography at Hewlett-Packard


                                    **Disclaimer: "IANAC"**  (**I** **A**m **N**ot **A** **C**ryptologist)
                                  </script>
                                </section>

                                <section data-markdown>
                                  <script type="text/template">
                                    # This talk

                                    ##Is Not

                                    - Advanced, sophisticated, or hardcore Cryptanalysis
                                    - Advanced, sophisticated, or hardcore Clojure

                                    ##Is

                                    - A look at Clojure's strengths for a particular problem domain
                                    - Just scratching the surface of Clojure for Crypto
                                  </script>
                                </section>

                                <section data-markdown data-transition="linear">
                                  <script type="text/template">
                                    # Taxonomy

                                    Cryptology = { Cryptography, Cryptanalysis }

                                    Cryptography = techniques for secure communication

                                    Cryptanalysis = techniques used to breach cryptographic systems

                                  </script>
                                </section>

                                <section data-markdown  data-transition="linear">
                                  <script type="text/template">
                                    ### Clojure Strengths re: Cryptology

                                    Clojure is particularly good for the **data-analysis** phase of cryptanalysis (e.g. data transformations and statistical analysis)

                                    See: clojure.math.combinatorics, core.matrix, hiphip (array), Incanter, Clojure Data Analysis Cookbook.

                                    Less good for: brute-force methods where **raw speed** is the dominant priority 
                                  </script>
                                </section>

                                <section data-transition="linear">

				    <h2>Warm Up</h2>
                                    "Frequency analysis is the basic tool for breaking most classical ciphers." -- Wikipedia

                                    <br><br>
                                    "'frequencies' is your friend" -- Clojure

                                    <pre><code data-trim contenteditable>
(frequencies "this is not a drill, it is a screwdriver")
==> {\space 8, \a 2, \c 1, \d 2, \e 2, \h 1, \i 6, \, 1, \l 2, \n 1, \o 1, \r 4, \s 4, \t 3, \v 1, \w 1}
                                    </code></pre>

                                </section>

                                <section>
				    <h2>Relative frequencies</h2>
                                    <h3> by percentage</h3>
                                    
                                    <pre><code data-trim contenteditable>
(defn pct-frequencies 
  [text]
  (let [pct #(double (/ (* %1 100) %2))
        histo (clojure.core/reverse (sort-by val (frequencies text)))]
    (map #(assoc % 1 (pct (% 1) (count text))) histo)))

(def fq (pct-frequencies "this is not a drill, it is a screwdriver"))
==> ([\space 20.0] [\i 15.0] [\s 10.0] [\r 10.0] [\t 7.5] [\l 5.0] [\e 5.0] [\d 5.0] [\a 5.0] [\w 2.5] [\v 2.5] [\o 2.5] [\n 2.5] [\, 2.5] [\h 2.5] [\c 2.5])
                                    </code></pre>

                                </section>

				<!-- Charts: nested vertical slides -->
                            <section>
                                <section>
				  <h2>Incanter bar-chart</h2>
                                    
                                    <pre><code data-trim contenteditable>
(view (bar-chart (map first fq) (map second fq)))
                                    </code></pre>

                                    <img width="500" height="500" src="fq-sm.png" alt="Letter Frequencies">

                                </section>
                                <section>
				  <h2>Letter Frequencies Chart from Wikipedia</h2>
                                    
                                    <img width="500" height="500" src="letter-frequencies-english-sm.png" alt="Letter Frequencies">

                                </section>
                            </section>

                                <section data-markdown>
                                  <script type="text/template">
                                    # Then what?
                                    - Perform frequency analysis on a ciphertext
                                        - E.g. just letters, case insensitive.
                                        - Also: frequency of
                                            - First letters in words
                                            - Letter pairs - e.g. "Th"
                                    - Correlate frequencies in ciphertext with frequencies in plaintext
                                    - This is effective on many "classic" ciphers. RSA? Not so much.
                                  </script>
                                </section>


				<!-- Charts2: nested vertical slides -->
                            <section>
                                <section>
				  <h2>Cryptogram Letter</h2><h2>Frequencies Chart</h2>
                                    
                                    <img width="500" height="500" src="letter-frequency-cryptgram-sm.png" alt="Letter Frequencies">

                                </section>
                                <section>
				  <h2>Plaintext Letter</h2><h2>Frequencies Chart</h2>
                                    
                                    <img width="500" height="500" src="letter-frequencies-mysample-sm.png" alt="Letter Frequencies">

                                </section>
                            </section>

                            <section>
                              <h1>Moving On</h1>
                            </section>

                            <section>
                              <h2>One Time Pad</h2>
                              <p></p>
                              <br>
                              <ul>
                                <LI>Unbreakable (in fact it's 
                                  <a href="http://en.wikipedia.org/wiki/Information-theoretic_security">mathematically proven</a> )
                                <LI>The "Pad" must be a <strong>perfectly random</strong> stream of bytes
                                <LI>Must be as long as the message (limits usefulness - <em>Why?</em>).
                                <LI>Encryption using a one-time pad is simply the <strong>exclusive-or</strong> (XOR) of pad & message.
                                <LI>A ONE-TIME PAD MUST ONLY BE USED <strong>ONCE!</strong> (thus the name!)
                              </ul>
                              <br><br>
                              If the one time pad is used more than once, we can notice correlations
                              in the ciphertext and it's <em>no longer
                              unbreakable</em>. 
                              <br><strong>That is the primary topic of this talk.</strong>
                            </section>

                                <section>
                                  <h2>The Challenge</h2>
                                  Decrypt a message, e.g.
                                  <br><br>
                                  32510ba98bb4abb8f71a1569a10cff655ccaee3fd81098588008...
                                  <br><br>
                                  Having seen other messages encrypted with the same pad
                                  <br><br>
                                      <ol>
                                        <li>315c4eeaa8b5f8aaf9174145bf43e1784b8fa00dc71d885a804e5ee9f...
                                        <li>234c02ecbbfbafa3ed18510abd11fa724fcda2018a1a8342cf064bbde...
                                        <li>32510ba9a7b2bba9b8005d43a304b5714cc0bb0c8a34884dd91304b8a...
                                        <li>32510ba9aab2a8a4fd06414fb517b5605cc0aa0dc91a8908c2064ba8a...
                                        <li>3f561ba9adb4b6ebec54424ba317b564418fac0dd35f8c08d31a1fe9e...
                                        <li>32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd2061bbde...
                                        <li>32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd90f1fa6e...
                                        <li>...
                                      </ol>
                                </section>

                                <section data-markdown>
                                  <script type="text/template">
                                    ## First Attempt
                                    Hint: “what happens when you xor with the space character?"

                                    - Tried XOR first ciphertext with the 2nd, 3rd, etc. looking for patterns.
                                    - Noticed some columns had lots of “normal alpha characters”. 
                                    - Noticed that ASCII space (0x20) is the bit that differs between small and capital letters. 
                                    - Laborious to do all the XORs one at a time. 
                                  </script>
                                </section>

                                <section>
                                  <h3>First Attempt</h3>
                                    <pre><code data-trim contenteditable>
(bit-xor ciphertext-1 ciphertext-N)
1.  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
2. ^R  ^P   L  ^F  ^S   N   W  \t  ^T  ^O  ^P   O  ^B   R  ^[  \n  ^D   B
3. ^C  \r   E   C  ^O  ^G   C  ^C   A  ^W  ^\  ^F  ^\   G   T  \t  ^G   O
4. ^C  \r   E   C  ^B  ^G   P  ^N  ^D  ^Q  ^@  \n  \n   T   T  ^X  ^W   O
5. ^N  \n   U   C  ^E  ^A   N   A  ^U   C  ^C  ^N  ^\   T   T  ^\  \n   ^@
6. ^C  \r   E  ^Q  ^D   N   A  ^T  ^D   C  ^@  ^X  ^]  ^@  ^@  ^Q  ^U   E 
7. ^C  \r   E  ^Q  ^D   N   A  ^T  ^D   C  ^@  ^X  ^]  ^@  ^@  ^Q  ^U   E 
8. ^@  ^@  ^@  ^@  ^@  ^@  ^@  ^U  ^D  ^F   T  ^[  ^Z   E   T  ^X  \n   I 
9. ^V   E  \b  ^S  ^S  ^G   V  ^G  ^U  ^F   Y  ^D  ^W   Y   ]   H   E   E 
10. w   1   H  ^F   A   -   O  \b  ^B  \n  ^G  \n   R   o  \f  ^N  \n   R 
                                    </code></pre>
                                    So: likely spaces in ciphertext-1 in columns: 3, 7, 14, 18, ...
                                </section>

                                <section data-markdown>
                                  <script type="text/template">
                                    #Clojure to the Rescue 
                                    * Excellent sequence handling 
                                    * Mapping over sequences is a primary problem solving technique 
                                    * REPL for exploration/experimentation 
                                    * Java Interop for basic type conversions 
                                  </script>
                                </section>

                                <section>
                                  <h2>Examples</h2>
                                  Map functions (e.g. XOR) over byte sequences
                                    <pre><code data-trim contenteditable>
                                        (map bit-xor s1 s2)
                                    </code></pre>
                                  Slicing – extract "columns" in data
                                    <pre><code data-trim contenteditable>
                                        (defn vslice [s n] (map #(nth s %) n)
                                    </code></pre>
                                  <h3>Also</h3>
                                  <ul>
                                    <li>Permutation (1xN, NxN) 
                                    <li>map, loop, for 
                                    <li>Also good matrix libs are available
                                  </ul>
                                </section>

				<section data-transition="linear">
                                <section data-transition="linear">
                                  <h2>The Basic Approach</h2>
                                  <ul>
                                    <li>The encrypted messages are “ciphertext” 
                                    <li>One-time pad encryption is simply performing an XOR with the message and they key (i.e. the “one-time pad” (OTP))
                                    <li>If two messages were encrypted with the same OTP, then XOR of the encrypted messages is the same as XOR of the non-encrypted messages – because the OTP gets XORed twice – cancelling it out.
                                    <li>Make use of the fact that Capital letters differ from small letters only in their 6th bit, or 0x20. Ox20 is ASCII for the space character, therefore, XOR 0x20 just flips its case. 
                                  </ul>
                                </section>

                                <section data-transition="linear">
                                  <h2>The Basic Approach (cont.)</h2>
                                  <ul>
                                    <li>XOR 2 messages. If the result is a Character [A-Za-z] then it’s more likely that one of the messages’ non-encrypted characters is a space!
                                    <li>XOR the encrypted space with Ox20 to find out what the OTP key value is at that position.
                                    <li>Test a given ciphertext byte against all the other ciphertext bytes in the same position (vertical slice).
                                    <li>If XOR indicates a likely space when tried against several ciphertexts, we’re pretty sure it’s a space and can assign a value to the OTP key at that position. 
                                    <li>Do this for every position within the collected ciphertexts in order to get as many known keys as possible.
                                  </ul>
                                </section>
				</section>

                                <section>
                                <section>
                                  <h2>Coding the Solution</h2>
                                  Utility: Convert hex-encoding to/from byte sequences
                                    <pre><code data-trim contenteditable>
(defn hex->bytes 
  "convert a hex encoded string into a list of integers" 
  [s] 
  (let [ctpairs (map #(apply str %) (partition 2 s))] 
        (map #(Integer/parseInt % 16) ctpairs))) 

crypto1.core> (hex->bytes "68697468657265") 
(104 105 116 104 101 114 101) 

(defn bytes->hex 
  "convert from an array of ints to a hex encoded string" 
  [b] 
  (let [newmsghex (map #(Integer/toHexString %) b)] 
    (apply str (map #(if (= 1 (count %)) (str "0" %) %) newmsghex)))) 

crypto1.core> (bytes->hex '(104 105 116 104 101 114 101)) 
"68697468657265" 
                                    </code></pre>
                                </section>

                                <section>
                                  <h2>Coding the Solution</h2>
                                  Utility: Convert ASCII to/from hex-encoding
                                    <pre><code data-trim contenteditable>
(defn hex->ascii 
  "convert a hex encoded string to ascii" 
  [s] 
  (->> (hex->bytes s) 
       (map char) 
       (apply str)))
       
crypto1.core> (hex->ascii "68697468657265") 
"hithere” 

(defn ascii->hex 
  "convert an ascii string to hex encoding" 
  [s] 
  (->> (seq s) 
       (map int) 
       bytes->hex))

crypto1.core> (ascii->hex "hithere") 
"68697468657265" 
                                    </code></pre>
                                </section>

                                <section>
                                  <h2>Coding the Solution</h2>
                                  Get input ciphertext into an easily manipulable form: 
                                    <pre><code data-trim contenteditable>
(hex->bytes "32510ba9 . . .")
(50 81 11 169 . . .)
                                    </code></pre>

map hex->bytes over an array of input ciphertext strings to create an array of sequences. 

                                    <pre><code data-trim contenteditable>
(map hex->bytes hex-encoded-ciphertext)

(49 92 78 234 168 181 248 170 249 23 65 69 191 67 225 120 75 143 160...
(35 76 2 236 187 251 175 163 237 24 81 10 189 17 250 114 79 205 162 1...
(50 81 11 169 167 178 187 169 184 0 93 67 163 4 181 113 76 192 187 12...
(50 81 11 169 170 178 168 164 253 6 65 79 181 23 181 96 92 192 170 13...
(63 86 27 169 173 180 182 235 236 84 66 75 163 23 181 100 65 143 172...
(50 81 11 251 172 251 185 190 253 84 65 93 162 67 225 105 94 202 189...
(50 81 11 251 172 251 185 190 253 84 65 93 162 67 225 105 94 202 189...
(49 92 78 234 168 181 248 191 253 17 21 94 165 6 181 96 65 198 160 12...
(39 25 70 249 187 178 174 173 236 17 24 65 168 26 188 48 14 202 160...
(70 109 6 236 233 152 183 162 251 29 70 79 237 44 237 118 65 221 170...)
                                    </code></pre>
                                </section>

                                <section>
                                  <h2>Coding the Solution</h2>
                                  Identify Likely Key Values
                                    <pre><code data-trim contenteditable>
(defn likely-space? 
  "xor nth element of vertical-slice with all the other elements,
  and return a bool to indicate that the number xors yielding a
  letter [A-Za-z] has crossed a threshold"
  [cbyte vertical-slice] 
  (let [xors (map bit-xor (repeat cbyte) vertical-slice) 
            isalpha? #(or (<= 65 % 90) (<= 97 % 122)) 
        alphas (count (filter isalpha? xors))] 
        (>= alphas 6))) 
     
(defn vertical-slice [s n] (map #(nth % n) s)) 
;;where “s” is a list of converted ciphertext strings. 
                                    </code></pre>

                                    Given a vertical slice, xor the nth element with every other one,
                                    counting the alpha characters that result. If there are a lot of
                                    alphas, the original message character is likely to be a space.
                                </section>

                                <section>
                                  <h2>Coding the Solution</h2>
                                  Find Likely Keys for One Vertical Slice
                                    <pre><code data-trim contenteditable>
(defn likely-keys-per-slice
  "s: a list of converted ciphertexts
   n: slice to analyze
   Call likely-space? on each element in turn, and return the key
   for any likely space character in the original text"
  [s n]
  (let [vs (map #(nth % n) s) ;; vertical slice
        xor2 #(if (nil? %) nil (bit-xor % 0x20))] 
    (->> (for [tb vs :when (likely-space? tb vs)] tb)
         first
         xor2)))
                                    </code></pre>
                                    Given the list of converted ciphertexts, select the nth slice and call
                                    likely-space? on each element in turn, collecting any likely space
                                    characters, and using XOR to reveal the OTP key value.
                                </section>

                                <section>
                                  <h2>Coding the Solution</h2>
                                  Get Likely Keys for All Vertical Slices

                                    <pre><code data-trim contenteditable>
(def ks (map #(likely-keys-per-slice (map hex->bytes ctx) %) (range 95)))
                                    </code></pre>

                                    Turn the hex-encoded strings (ctx)
                                    into to a list of byte sequences.
                                    Get the likely keys for every
                                    vertical slice (for slice indexes
                                    [0..95])
                                    <br><br>
                                    <em>At this point, the only remaining task is to XOR the likely keys
                                    (ks) with the unknown ciphertext in order to reveal the secret
                                    message.</em>

                                    <pre><code data-trim contenteditable>
(defn decrypt [likelykeys ct]
  (->>
   (map #(if (nil? %) 0x5F (bit-xor %1 %2)) likelykeys (hex->bytes ct))
   (map char)
  (apply str)))

(decrypt ks secret-message)

"The Bosson Clo_ure_Group fill meet  y Akamai on Maw 8th"
                                    </code></pre>

                                </section>
                                </section>

				<!-- Example of markdown
                                <section data-markdown>
                                  <script type="text/template">
                                    # Title
                                  </script>
                                </section>
                                -->

				<!-- Example of html
                                <section>
                                  <h2>Title</h2>
                                    <pre><code data-trim contenteditable>
                                    </code></pre>
                                </section>
                                -->

                                <!-- Recovering The Exact Key -->
				<section data-transition="linear">
                                  <section data-transition="linear">
                                    <h2>Recovering the Exact Key</h2>
                                    1) Play "wheel of fortune" on the approx message. (I.e. guess it)
                                    <pre><code data-trim contenteditable>

(decrypt ks secret-message))
==>          "The Bosson Clo_ure_Group fill meet  y Akamai on Maw 8th"
(def realmsg "The Boston Clojure Group will meet at Akamai on May 8th")
                                    </code></pre>
                                    2) Turn the guessed message into a byte sequence
                                    <pre><code data-trim contenteditable>
(def realmsg-bytes (map int realmsg))
==> (84 104 101 32 66 111 115 116 111 110 32 67 108 111 106 117 114 101 32 71 114 111 117 112 32 119 105 108 108 32 109 101 101 116 32 97 116 32 65 107 97 109 97 105 32 111 110 32 77 97 121 32 56 116 104)
                                    </code></pre>

                                  </section>
                                  <section data-transition="linear">
                                    <h2>Recovering the Exact Key (cont.)</h2>
                                    3) XOR the guessed message with
                                    the encrypted real message to yield the new real-key guess
                                    <pre><code data-trim contenteditable>

;; crypto2.core> secret-message
==> "32510ba98bb4abb8f71a1569a10cff655ccaee3fd8109858800802a5e109a86e0cc413fb6dd8eb2b7bf10c19afefae468a0287d02a4520"

(def secret-message-bytes (hex->bytes secret-message))
==> (50 81 11 169 139 180 171 184 247 26 21 105 161 12 255 101 92 202 238 63 216 16 152 88 128 8 2 165 225 9 168 110 12 196 19 251 109 216 235 43 123 241 12 25 175 239 174 70 138 2 135 208 42 69 32)

(def real-key (map bit-xor secret-message-bytes realmsg-bytes))
==> (102 57 110 137 201 219 216 204 152 116 53 42 205 99 149 16 46 175 206 120 170 127 237 40 160 127 107 201 141 41 197 11 105 176 51 154 25 248 170 64 26 156 109 112 143 128 192 102 199 99 254 240 18 49 72)
                                    </code></pre>
                                  </section>
                                  <section data-transition="linear">
                                    <h2>Recovering the Exact Key (cont.)</h2>
                                    4) Try our new "real" key on
                                    on the encrypted message. By definition it will give back the exact guessed message.
                                    <pre><code data-trim contenteditable>
(decrypt real-key secret-message)
==> "The Boston Clojure Group will meet at Akamai on May 8th"
                                    </code></pre>
                                    5) Try it on other messages encrypted with that same key
                                    <pre><code data-trim contenteditable>
(pprint (map #(decrypt real-key (nth ctx %)) (range 10)))
==> ("We can factor the number 15 with quantum computers. We "
==>  "Euler would probably enjoy that now his theorem becomes"
==>  "The ciphertext produced by a weak encryption algorithm "
==>  "You don't want to buy a set of car keys from a guy who "
==>  "There are two types of cryptography - that which will k"
==>  "We can see the point where the chip is unhappy if a wro"
==>  "A (private-key)  encryption scheme states 3 algorithms,"
==>  " The Concise OxfordDictionary (2006) deï¬nes crypto as")
                                    </code></pre>
                                    This process can be repeated. Choose a longer ciphertext to extend the "real key" discovery.
                                  </section>
                                </section>

                                <section>
                                  <h1>End</h1>
                                </section>

				<!-- Examples -->

				<section id="themes">
					<h2>Themes</h2>
					<p>
						Reveal.js comes with a few themes built in: <br>
						<a href="?#/themes">Default</a> -
						<a href="?theme=sky#/themes">Sky</a> -
						<a href="?theme=beige#/themes">Beige</a> -
						<a href="?theme=simple#/themes">Simple</a> -
						<a href="?theme=serif#/themes">Serif</a> -
						<a href="?theme=night#/themes">Night</a> <br>
						<a href="?theme=moon#/themes">Moon</a> -
						<a href="?theme=solarized#/themes">Solarized</a>
					</p>
					<p>
						<small>
							* Theme demos are loaded after the presentation which leads to flicker. In production you should load your theme in the <code>&lt;head&gt;</code> using a <code>&lt;link&gt;</code>.
						</small>
					</p>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
